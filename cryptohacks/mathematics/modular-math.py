import gmpy2
from Crypto.Util.number import *
import owiener
from sympy.solvers.diophantine.diophantine import base_solution_linear

# 1
def qr():
	x = set([i**2 % 29 for i in range(29)])
	y = [i for i in range(29) if i**2 % 29 == 6]
	return y

# 2
def euler_criterion(a, p):
	return pow(a, (p-1)//2, p)

# algorithm from wiki
def tonelli_shanks(n,p):
	if n % p == 0:
		return 0
	
	Q = p - 1
	S = 0
	while Q % 2 == 0:
		S += 1
		Q //= 2
	# print("Q=", Q)
	# print("S=", S)

	# Find a quadratic non-residue of p by brute force search
	z = 2
	while euler_criterion(z, p) ==1:
		z += 1
	print("z=", z)

	# Initialize variables
	M = S
	c = pow(z, Q, p)
	t = pow(n, Q, p)
	R = pow(n, (Q + 1)//2, p)
	
	while t != 1:
		i = 0
		temp = t 
		while temp != 1:
			i += 1
			temp = (temp * temp) % p
		
		# Calculate b, M, c, t, R
		pow2 = 2 ** (M - i - 1)
		b = pow(c, pow2, p)
		M = i
		c = (b * b) % p
		t = (t * b * b) % p
		R = (R * b) % p

	return R

def legendre_symbol():
	p = 101524035174539890485408575671085261788758965189060164484385690801466167356667036677932998889725476582421738788500738738503134356158197247473850273565349249573867251280253564698939768700489401960767007716413932851838937641880157263936985954881657889497583485535527613578457628399173971810541670838543309159139
	ints = [25081841204695904475894082974192007718642931811040324543182130088804239047149283334700530600468528298920930150221871666297194395061462592781551275161695411167049544771049769000895119729307495913024360169904315078028798025169985966732789207320203861858234048872508633514498384390497048416012928086480326832803, 45471765180330439060504647480621449634904192839383897212809808339619841633826534856109999027962620381874878086991125854247108359699799913776917227058286090426484548349388138935504299609200377899052716663351188664096302672712078508601311725863678223874157861163196340391008634419348573975841578359355931590555, 17364140182001694956465593533200623738590196990236340894554145562517924989208719245429557645254953527658049246737589538280332010533027062477684237933221198639948938784244510469138826808187365678322547992099715229218615475923754896960363138890331502811292427146595752813297603265829581292183917027983351121325, 14388109104985808487337749876058284426747816961971581447380608277949200244660381570568531129775053684256071819837294436069133592772543582735985855506250660938574234958754211349215293281645205354069970790155237033436065434572020652955666855773232074749487007626050323967496732359278657193580493324467258802863, 4379499308310772821004090447650785095356643590411706358119239166662089428685562719233435615196994728767593223519226235062647670077854687031681041462632566890129595506430188602238753450337691441293042716909901692570971955078924699306873191983953501093343423248482960643055943413031768521782634679536276233318, 85256449776780591202928235662805033201684571648990042997557084658000067050672130152734911919581661523957075992761662315262685030115255938352540032297113615687815976039390537716707854569980516690246592112936796917504034711418465442893323439490171095447109457355598873230115172636184525449905022174536414781771, 50576597458517451578431293746926099486388286246142012476814190030935689430726042810458344828563913001012415702876199708216875020997112089693759638454900092580746638631062117961876611545851157613835724635005253792316142379239047654392970415343694657580353333217547079551304961116837545648785312490665576832987, 96868738830341112368094632337476840272563704408573054404213766500407517251810212494515862176356916912627172280446141202661640191237336568731069327906100896178776245311689857997012187599140875912026589672629935267844696976980890380730867520071059572350667913710344648377601017758188404474812654737363275994871, 4881261656846638800623549662943393234361061827128610120046315649707078244180313661063004390750821317096754282796876479695558644108492317407662131441224257537276274962372021273583478509416358764706098471849536036184924640593888902859441388472856822541452041181244337124767666161645827145408781917658423571721, 18237936726367556664171427575475596460727369368246286138804284742124256700367133250078608537129877968287885457417957868580553371999414227484737603688992620953200143688061024092623556471053006464123205133894607923801371986027458274343737860395496260538663183193877539815179246700525865152165600985105257601565]
	x = -1
	for i in ints:
		if euler_criterion(i, p) == 1: # 1 means that the number is a quadratic residue
			x=i # this is the quadratic residue

	# a^2 = x mod p
	# b^p cong b mod p
	gmpy2.get_context().precision = 10000
	# temp = gmpy2.div(p+1, 4)
	# print(temp)
	a = pow(x, int(gmpy2.div(p + 1,4)),p)
	# a = (pow(x, p/2, p))
	# print(int(a) == a)
	print(a)

def custom_crt(mods, a):
	# used http://homepages.math.uic.edu/~leon/mcs425-s08/handouts/chinese_remainder.pdf
	m = 1
	for i in mods:
		m*=i

	z = [1] * len(mods)
	for i in range(len(z)):
		for j in range(len(z)):
			if j != i:
				z[i] *= mods[j]

	y = [1] * len(mods)
	for i in range(len(z)):
		y[i] = gmpy2.invert(z[i], mods[i])

	w = [1] * len(mods)
	for i in range(len(w)):
		w[i] = y[i] * z[i] % m

	x = 0
	for i in range(len(w)):
		x += w[i] * a[i]

	x %= m
	return x


def modular_binomials():
	# https://sites.millersville.edu/bikenaga/number-theory/modular-arithmetic/modular-arithmetic.html
	# N = p*q
	# c1 = (2*p + 3*q)**e1 mod N
	# c2 = (5*p + 7*q)**e2 mod N

	N = 14905562257842714057932724129575002825405393502650869767115942606408600343380327866258982402447992564988466588305174271674657844352454543958847568190372446723549627752274442789184236490768272313187410077124234699854724907039770193680822495470532218905083459730998003622926152590597710213127952141056029516116785229504645179830037937222022291571738973603920664929150436463632305664687903244972880062028301085749434688159905768052041207513149370212313943117665914802379158613359049957688563885391972151218676545972118494969247440489763431359679770422939441710783575668679693678435669541781490217731619224470152467768073
	e1 = 12886657667389660800780796462970504910193928992888518978200029826975978624718627799215564700096007849924866627154987365059524315097631111242449314835868137
	e2 = 12110586673991788415780355139635579057920926864887110308343229256046868242179445444897790171351302575188607117081580121488253540215781625598048021161675697
	c1 = 14010729418703228234352465883041270611113735889838753433295478495763409056136734155612156934673988344882629541204985909650433819205298939877837314145082403528055884752079219150739849992921393509593620449489882380176216648401057401569934043087087362272303101549800941212057354903559653373299153430753882035233354304783275982332995766778499425529570008008029401325668301144188970480975565215953953985078281395545902102245755862663621187438677596628109967066418993851632543137353041712721919291521767262678140115188735994447949166616101182806820741928292882642234238450207472914232596747755261325098225968268926580993051
	c2 = 14386997138637978860748278986945098648507142864584111124202580365103793165811666987664851210230009375267398957979494066880296418013345006977654742303441030008490816239306394492168516278328851513359596253775965916326353050138738183351643338294802012193721879700283088378587949921991198231956871429805847767716137817313612304833733918657887480468724409753522369325138502059408241232155633806496752350562284794715321835226991147547651155287812485862794935695241612676255374480132722940682140395725089329445356434489384831036205387293760789976615210310436732813848937666608611803196199865435145094486231635966885932646519

	assert (isPrime(e1) == True)
	assert (isPrime(e2) == True)

	# c1 = ((2p) ** e1 % e1) + ((3q) ** e1 % e1) % N
	# c1 = (2 ** e1 * p ** e1 % e1) + (e ** e1 * q ** 31 % e1) % N
	
#######################################################

	# c1 = pow(2p, e1) + pow(3q, e1) % N
	# c2 = pow(5p, e2) + pow(7q, e2) % N
	# pow(5c1, e2, N) = pow (10p, e1 * e2) + pow(15q, e1 * e2) % N
	# pow(2c2, e1, N) = pow (10p, e1 * e2) + pow(14q, e1 * e2) % N
	# pow (5c1, e2, N) - pow(2c2, e1, N) = pow(q, e1 * e2, N)
	# invert(e1 * e2, N) = d
	# pow (q, e1 * e2 * d, N) = q
	# N / q = p

	assert (math.gcd (e1 * e2, N) == 1)
	c1 = (c1 * pow(5, e1, N)) % N
	c2 = (c2 * pow(2, e2, N)) % N
	c1 = pow( c1, e2, N)
	c2 = pow( c2, e1, N)
	q = (c1 - c2) % N
	print(q)
	# Cannot do this
	# d = gmpy2.invert(e1 * e2, N)
	# q = pow(q, e1 * e2 * d, N)
	# p = N // q
	# assert ( q * p == N)

	q = math.gcd(N, q)
	p = N // q
	assert(q * p == N)
	print("crypto{%d,%d}"%(p,q))

	# Flag: crypto{112274000169258486390262064441991200608556376127408952701514962644340921899196091557519382763356534106376906489445103255177593594898966250176773605432765983897105047795619470659157057093771407309168345670541418772427807148039207489900810013783673957984006269120652134007689272484517805398390277308001719431273,132760587806365301971479157072031448380135765794466787456948786731168095877956875295282661565488242190731593282663694728914945967253173047324353981530949360031535707374701705328450856944598803228299967009004598984671293494375599408764139743217465012770376728876547958852025425539298410751132782632817947101601}
	# https://ctftime.org/writeup/15438



	# temp1 = base_solution_linear(c1, a, b)
	# temp2 = base_solution_linear(c2, c, d)
	# assert (c1 % N == (temp1[0] * a + temp1[1] * b) % N)
	# assert (c2 % N == (temp2[0] * c + temp2[1] * d) % N)
	# assert(temp1[0] < e1)


	

#######################################################

	# Failed
	# d1 = owiener.attack(e1, N)
	# d2 = owiener.attack(e2, N)
	# print(d1, d2)





def main():
	# print("quad residue: ", qr())
	# print("legendre_symbol: ", legendre_symbol())
	# a = 8479994658316772151941616510097127087554541274812435112009425778595495359700244470400642403747058566807127814165396640215844192327900454116257979487432016769329970767046735091249898678088061634796559556704959846424131820416048436501387617211770124292793308079214153179977624440438616958575058361193975686620046439877308339989295604537867493683872778843921771307305602776398786978353866231661453376056771972069776398999013769588936194859344941268223184197231368887060609212875507518936172060702209557124430477137421847130682601666968691651447236917018634902407704797328509461854842432015009878011354022108661461024768
	# p = 30531851861994333252675935111487950694414332763909083514133769861350960895076504687261369815735742549428789138300843082086550059082835141454526618160634109969195486322015775943030060449557090064811940139431735209185996454739163555910726493597222646855506445602953689527405362207926990442391705014604777038685880527537489845359101552442292804398472642356609304810680731556542002301547846635101455995732584071355903010856718680732337369128498655255277003643669031694516851390505923416710601212618443109844041514942401969629158975457079026906304328749039997262960301209158175920051890620947063936347307238412281568760161
	# print("mod sq rt: ", tonelli_shanks(a, p))
	
	# ### Testing crt
	
	# a = [2,3,5]
	# m = [5,11,17]
	# print("crt problem", custom_crt(m,a));

	modular_binomials()



if __name__ == '__main__':
	main()