# The issue is that the prime used in diffie hellman is not a safe prime. 
# Specifically, it is not a Sophie Germain prime number. Sophie Germain prime numbers are prime numbers p, s.t. the number 2*p + 1 is also a prime
# The generator is created in such a way that the generator will be in the subgroup generated by q, a factor of 2*q*r. This is problematic because it means that we can easily solve the discrete logarithm problem for that specific subgroup

# https://florianjw.de/en/insecure_generators.html
# https://crypto.stackexchange.com/questions/102292/proof-that-checking-if-gk-bmod-p-ne1-finds-a-generator-of-a-cyclic-group

from pwn import *
from Crypto.Util.number import bytes_to_long, long_to_bytes
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad
from hashlib import sha256

r = remote('167.172.61.89',30694)
def sandbox():
    # p = 23
    # for i in range(1,23):
    #     #print(pow(5,i,p))
    #     print("i: ", i, pow(i,2, 23))
    # Given values
    p = 4150987978721
    g = 45625815067596159614819605836786567563184041390753136515525259801138337786782016047324277873813622207934577297674340546330607023833312239457225668186685274160744493751
    A = 30907230349663593254778018273801046480224729411572874115331525007790463304579354229248841482205148120451457014301116483369659085917542792182810963453330388109817243383

    # Use Sage's discrete_log to solve for b
    b = discrete_log(Mod(A, p), Mod(g, p), operation='*')

    print(b)

    # g^a % p = A
    # 
    p2 = 80493489296309529399762034832260693493944548742062072728482397745227656042173732239507383687670919732364492535195979115516246539823201364686667884857741561638751999023
    temp = (pow(g, b, p2))
    print(temp)
    print(int(temp) % p)

    sol = int(pow(g,b,p))
    print("sol: ", sol)
    assert(pow(g,b,p) == A)
    print(A % sol)
    print(pow(g,p,p2)) # gives 1
    print(pow(g,p2,p2))

    # Create an integer mod ring to perform arithmetic operations in 0 -> p2-1
    # Convert generator g and val A into elements of the ring which allows us to do arithmetic operations mod p2
    # Solve DLP for the subgroup p
    R = IntegerModRing(p2)
    g_in_R = R(g)
    A_in_R = R(A)

    # Compute the discrete logarithm in the subgroup of order p
    a_prime = discrete_log(A_in_R, g_in_R, ord=p)
    print(a_prime)
    print(b)
    print(pow(g,a_prime * ((p2-1)//p), p2))
    print(pow(g, a_prime * (p-1), p)) # gives 1
    print(pow(g, a_prime * (p-1), p2)) # does not give 1

def solve():
    r.recvuntil("> ")
    r.sendline("1")
    p = int(r.recvline().decode().strip('\n').split("= ")[1])
    g = int(r.recvline().decode().strip('\n').split("= ")[1])
    A = int(r.recvline().decode().strip('\n').split("= ")[1])
    B = int(r.recvline().decode().strip('\n').split("= ")[1])
    r.recvuntil("> ")
    r.sendline("3")
    enc_flag = bytes.fromhex(r.recvline().decode().strip('\n').split("= ")[1])
    print(p)
    print(g)
    print(A)
    print(B)
    print(enc_flag)
    factors = factor(p-1)
    print("factors: ")
    print(factors)
    p_fac = factors[1][0]
    print(p_fac)
    R = IntegerModRing(p)
    g_in_R = R(g)
    A_in_R = R(A)
    a = discrete_log(A_in_R, g_in_R, ord=p_fac)
    ss = int(pow(B,a,p))

    key = sha256(long_to_bytes(ss)).digest()[:16]
    cipher = AES.new(key, AES.MODE_ECB)
    ct = cipher.decrypt(enc_flag).hex()
    print(long_to_bytes(int(ct,16)))


def main():
    # Flag: HTB{00ps_wh4t_4_sm411_0rd3r}
    solve()


if __name__ == '__main__':
    main()
