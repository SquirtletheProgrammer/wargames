import gmpy2
import math
from sympy.ntheory.modular import crt 


# #----------RSA PART----------
# p= 0x16498bf7cc48a7465416e0f9ec8034f4030991e73aff9524ef74cc574228e36e6e1944c7686f69f0d1186a69b7aa77d7e954edc8a6932f006786f4648ecc8d4f4d3f6c03d9a1ee9fe61b28b6dd2791a63be581b8811a8ac90a387241ea68b7d36b4a274f64c7a721ad55cfcef23cd14c72542f576e4b507c11c4fa198e80021d484691b
# e= 0x69420
# ct1= 0xa82b37d57b6476fa98f6ee7c278d934bd96c49aa1c5399552d25211230d76cb16ade049572bf631e3849903638d41c884957b9592d0aa072b2bdc3105fe0e3253284f85286ec613966f9cde77ae06e2053dc2254e44ca673b4c76879eff84e5fc32af976c1bfafe147a277d72aad674db749ed8f34d2ebe8189cf12afc9baa17764e4b
# #----------DH PART----------

# # modulo
# # used to exchange keys maybe
# n= 0xbe30ccaf896c16f53515e298df25df9158d0a95295c119f0444398b94fae26c0b4cf3a43b120cf0fb657069e0621eb1d2dd832eef3065e80ddbc35854dd4585cc41fd6a5b36339c0d9fcc066272be6818be6a624f75482bbb9c408010ac8c27b20397d870bfcb14e6318097b1601f99e391c9b68c5c586f8da561ff8507be9212713b910b748370ce692c11afa09b74ce80c5f5dd72046415aeed85e1ecedca14abe17ed19ab97729b859120699d9f80dd13f8483773df15b938b8399702a6e846b8728a70f1940d4c6e5835a06a89925eb1ec91a796f270e2d9be1a2c4bee5517109c161f04333d9c0d4034fbbd2dcf69fe734b759a89937f4d8ea0ee6b8385aae14a2cce361
# # generator
# g= 0x69420 
# ct2= 0x65d57a564b8a8667a956705442063392b9b975b8ef869a6dbed04d6e585351f559fe6f5d96823f60b7306740fe2cf5aa81e4a12736d4f0a4826cbc8b4312643af19c75432b4ab222837031851f312df5d707b39bdf2d272f25c1947f3e2943f3592cb0519fee8f4b458021b6b8ee4eabeeae5127d412df4f6a88f66d7cc34c6bb77e0a1440737d0e167f9489f0c7fbfd7f6a5870b4b2865d29b91f6c2b375951e85b1b9f03887d4d3c4a6218111a95021ed1d554c57269e7830c3e7b8e17d13e1fb75ee9f305833d0cb6bfab738572cdbbc8b33b878ad25f78d47d7f449a6c348f5f9f1df3e09f924534a3669b4e69bd0411d154ec756b210691e2efc4a55aa664d938a868f4d


def trans(x):
	# return bytes.fromhex(hex(x)[2:])
	try:
		return bytes.fromhex(hex(x)[2:])
	except: 
		return bytes.fromhex('0' + hex(x)[2:])

	return bytes.fromhex('0' + hex(x)[2:])

# Determines if n is a quadratic residue of an 
# odd prime p by using Euler's criterion.
def is_quadratic_residue(n, p):
	if n % p == 0:
		return True
	return pow(n, (p - 1)//2, p) == 1


def tonelli_shanks(n,p):
		# Case when p|n, so n=0(mod p). The square root of 0 is 0. 
	if n % p == 0:
		return 0
	
	# So now p=1(mod 4), (although this is not needed in the algorithm).
	# Write p - 1 = (2^S)(Q) where Q is odd
	Q = p - 1
	S = 0
	while Q % 2 == 0:
		S += 1
		Q //= 2
	# print("Q=", Q)
	# print("S=", S)

	# Find a quadratic non-residue of p by brute force search
	z = 2
	while is_quadratic_residue(z, p):
		z += 1
	# print("z=", z)

	# Initialize variables
	M = S
	c = pow(z, Q, p)
	t = pow(n, Q, p)
	R = pow(n, (Q + 1)//2, p)
	
	while t != 1:

		# Calculate i
		i = 0
		temp = t 
		while temp != 1:
			i += 1
			temp = (temp * temp) % p
		
		# Calculate b, M, c, t, R
		pow2 = 2 ** (M - i - 1)
		b = pow(c, pow2, p)
		M = i
		c = (b * b) % p
		t = (t * b * b) % p
		R = (R * b) % p

	# We have found a squ
	return R

def main():
	gmpy2.get_context().precision = 10000

	p= 0x16498bf7cc48a7465416e0f9ec8034f4030991e73aff9524ef74cc574228e36e6e1944c7686f69f0d1186a69b7aa77d7e954edc8a6932f006786f4648ecc8d4f4d3f6c03d9a1ee9fe61b28b6dd2791a63be581b8811a8ac90a387241ea68b7d36b4a274f64c7a721ad55cfcef23cd14c72542f576e4b507c11c4fa198e80021d484691b
	e= 0x69420
	ct1= 0xa82b37d57b6476fa98f6ee7c278d934bd96c49aa1c5399552d25211230d76cb16ade049572bf631e3849903638d41c884957b9592d0aa072b2bdc3105fe0e3253284f85286ec613966f9cde77ae06e2053dc2254e44ca673b4c76879eff84e5fc32af976c1bfafe147a277d72aad674db749ed8f34d2ebe8189cf12afc9baa17764e4b
	phi = p-1
	const = 32
	e //= const
	d = gmpy2.invert(e, phi)
	# print(d)
	p32 = pow(ct1, d, p)
	# print(p32)

	while (const != 1):
		const //= 2
		p32 = tonelli_shanks(p32, p)
	# print(trans(-p32%p))

	# FIRST PART OF THE FLAG BABY: HTB{why_d1d_y0u_m3ss_3v3ryth1ng_up_1ts_n0t_th4t_h4rd
	p= 0x16498bf7cc48a7465416e0f9ec8034f4030991e73aff9524ef74cc574228e36e6e1944c7686f69f0d1186a69b7aa77d7e954edc8a6932f006786f4648ecc8d4f4d3f6c03d9a1ee9fe61b28b6dd2791a63be581b8811a8ac90a387241ea68b7d36b4a274f64c7a721ad55cfcef23cd14c72542f576e4b507c11c4fa198e80021d484691b
	n= 0xbe30ccaf896c16f53515e298df25df9158d0a95295c119f0444398b94fae26c0b4cf3a43b120cf0fb657069e0621eb1d2dd832eef3065e80ddbc35854dd4585cc41fd6a5b36339c0d9fcc066272be6818be6a624f75482bbb9c408010ac8c27b20397d870bfcb14e6318097b1601f99e391c9b68c5c586f8da561ff8507be9212713b910b748370ce692c11afa09b74ce80c5f5dd72046415aeed85e1ecedca14abe17ed19ab97729b859120699d9f80dd13f8483773df15b938b8399702a6e846b8728a70f1940d4c6e5835a06a89925eb1ec91a796f270e2d9be1a2c4bee5517109c161f04333d9c0d4034fbbd2dcf69fe734b759a89937f4d8ea0ee6b8385aae14a2cce361
	# generator
	g= 0x69420 
	ct2= 0x65d57a564b8a8667a956705442063392b9b975b8ef869a6dbed04d6e585351f559fe6f5d96823f60b7306740fe2cf5aa81e4a12736d4f0a4826cbc8b4312643af19c75432b4ab222837031851f312df5d707b39bdf2d272f25c1947f3e2943f3592cb0519fee8f4b458021b6b8ee4eabeeae5127d412df4f6a88f66d7cc34c6bb77e0a1440737d0e167f9489f0c7fbfd7f6a5870b4b2865d29b91f6c2b375951e85b1b9f03887d4d3c4a6218111a95021ed1d554c57269e7830c3e7b8e17d13e1fb75ee9f305833d0cb6bfab738572cdbbc8b33b878ad25f78d47d7f449a6c348f5f9f1df3e09f924534a3669b4e69bd0411d154ec756b210691e2efc4a55aa664d938a868f4d
	# print(n)
	# print(g)
	# print(ct2)
	q = n//p
	# print(q)

	# found using alpertron for g^xp = ct2 mod p
	kp = 0
	xp = 1333647771826129906056278980508785116695001357398405010264712880010822066437928270470093887443647579332557329757513503832688236838814545646539928049413880950956136391197700699813257009513030650710096103937450573603079886862042789301653172344151731360918260335579808862271014412080624561537897979314727207446470188301\
	+ 2100597191236862411973123184673222390029361412634375676811383630091967723602897705208854139513327705418840522104410271985778087477636285771639551773018473451844243204190875248518748762236574766561778114516538828518726261981381313004189199195300204873125911752732961129454366019842676645748294495098918135199007126669 * kp

	kq = 0
	xq = 2248237925279582319646346402167252499424555860028602832387207824347301477610684362756745372458799004275280799304910420404269790625413034441525997676464275232206297649095612480172888211521015846455387388707653809767187874172857528680924943045273311447383766726890650161662310150531795567852223701545458237821806704227\
	+ 25737553036453033170874873232492616472696251153498345345893349066914349319700028526259065151440470760781885101651616163782998343068021108194360596481454344775056268387636520767391616783538213196153998980567585557740463660083917063025907541863194906635695830144597030344814258845557193440907517374289359866191267367218 * kq

	
	assert(pow(g, xp, p) == ct2 % p)
	assert(pow(g, xq, q) == ct2 % q)

	m = [p-1, q-1] # modulo
	v = [xp, xq] 
	ret = crt (m, v)
	print(ret[0]) # gives x in g^x
	# # check
	assert(xp == ret[0] % (p-1))
	assert(xq == ret[0] % (q-1))
	print(trans(ret[0]))

	# the second part of the flag BABY: _ju5t_us3_pr0p3r_p4r4m3t3rs_f0r_4ny_crypt0syst3m...}




if __name__ == '__main__':
	main()

