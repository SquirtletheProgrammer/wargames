---
title: nebula
tags: privilege escalation, C, networking
note: https://secinject.wordpress.com/category/nebula-exploit-exercises/ has really good writeups for this
---

### Flag 0
<img src = "/csec-writeups/exploited/nebula/0-1.png" alt="">
I found a file with user flag00 permissions and executed the program.  

<img src = "/csec-writeups/exploited/nebula/0-2.png" alt="">

### Flag 1
For this challenge, I created a shell script called echo in the directory /home/level01. /usr/bin/env runs a command according to our environment. I modified the PATH variable so that it would visit my directory before anywhere else in the PATH variable to find the program echo.  
Note: /home/levelxx is a place where you can write programs and whatnot, while /home/flagxx usually contains the program that you need to exploit.
<img src = "/csec-writeups/exploited/nebula/1-1.png" alt="">

### Flag 2
This challenge involves a command injection. By modifying the USER variable, I can inject bash code into the buffer, which gets called by system.
<img src = "/csec-writeups/exploited/nebula/2-1.png" alt="">

### Flag 3
For this challenge, there is a script that is run by crontab called writable.sh. It executes all of the files in the writable.d directory, so I created a simple shell script in the writable that runs getflag and pipes the output into a file in tmp.  
<img src = "/csec-writeups/exploited/nebula/3-1.png" alt="">
<br/>
<img src = "/csec-writeups/exploited/nebula/3-2.png" alt="">

### Flag 4
The program for this flag conducts a check for the string "token" and exits the program if the string is detected. In order to read the token file, I created a symbolic link and passed that as the file to read instead.
<img src = "/csec-writeups/exploited/nebula/4.png" alt="">

### Flag 5
There is a backup zip file that contains an ssh key that we can use to login as flag05 user.
<img src = "/csec-writeups/exploited/nebula/5-1.png" alt=""> <br/>
<img src = "/csec-writeups/exploited/nebula/5-2.png" alt=""> <br/>
<img src = "/csec-writeups/exploited/nebula/5-3.png" alt=""> <br/>
<img src = "/csec-writeups/exploited/nebula/5-4.png" alt=""> <br/>

### Flag 6
Use John the Ripper to crack the password hash associated with the flag06 user in /etc/passwd.
<img src = "/csec-writeups/exploited/nebula/6-1.png" alt=""> <br/>
<img src = "/csec-writeups/exploited/nebula/6-2.png" alt="">

### Flag 7
For this challenge, the thttpd.conf file shows that the server is run with flag07 user permissions. Additionally, we can connect to the server on port 7007. Seeing this, we can do a simple command injection to get the flag by setting host equal to the command ";getflag". 
Note: the flag -P is --directory-prefix. It basically sets the directory to place the output of the wget command into. Additionally, you have to make sure that the wget request / command is url encoded using %3B to replace the semicolon.
<img src = "/csec-writeups/exploited/nebula/7.png" alt="">

### Flag 8
I used wireshark to analyze the packets since the file has the extension pcap, which stands for packet capture. I right clicked the first packet, and then clicked on follow stream. 

<img src = "/csec-writeups/exploited/nebula/8-1.png" alt="">

I also switched from ascii to hexdump and saw that the "." character was the backspace character after examining the hex more closely. Usually "." is used to replace unreadable characters. The password is backd00Roomate.

<img src = "/csec-writeups/exploited/nebula/8-2.png" alt=""> 

### Flag 9:
The issue with this php code is in the function preg_replace and involves the use of complex (curly) syntax string interpolation method to get code execution. This vulnerability is also outdated. A good explanation of the vulnerability can be found here: <a href="https://medium.com/@roshancp/command-execution-preg-replace-php-function-exploit-62d6f746bda4"> https://medium.com/@roshancp/command-execution-preg-replace-php-function-exploit-62d6f746bda4 </a> or in a simple google search.  
<img src = "/csec-writeups/exploited/nebula/9.png" alt="">


### Flag 10:

The vulnerability is in the use of the function access, and it involves a race condition. Basically, use the command  
nc -lvk 18211  
on level10@192.168.56.101 and wait for ln to create symbolic link. This gives us the password for flag10 ssh. This is a good description of the problem and exploit associated with the vulnerability: <a href="https://www.usenix.org/legacy/publications/library/proceedings/sec04/tech/full_papers/dean/dean_html/accessopen.html"> https://www.usenix.org/legacy/publications/library/proceedings/sec04/tech/full_papers/dean/dean_html/accessopen.html </a>.

### Flag 11:
The solution code for this problem can be found here: <a href="https://github.com/dillonwu-97/csec-code/blob/main/exploit-ed/nebula/flag11.py"> https://github.com/dillonwu-97/csec-code/blob/main/exploit-ed/nebula/flag11.py </a>. There is another way to get the flag for this box.

### Flag 12:   
This is a simple command injection. 
<img src = "/csec-writeups/exploited/nebula/12-1.png" alt="">  <br/>
<img src = "/csec-writeups/exploited/nebula/12-2.png" alt=""> 

### Flag 13:
For this challenge, I used gdb to find the value of the token. 
<img src = "/csec-writeups/exploited/nebula/13-1.png" alt=""> <br/>
<img src = "/csec-writeups/exploited/nebula/13-2.png" alt=""> 

### Flag 14:
This is another simple decryption problem. I typed in hhhh to see what the output of the encryption program was, and saw that it was hijk. The code solution for this problem is here: <a href="https://github.com/dillonwu-97/csec-code/blob/main/exploit-ed/nebula/flag14.py"> https://github.com/dillonwu-97/csec-code/blob/main/exploit-ed/nebula/flag14.py </a>

<img src = "/csec-writeups/exploited/nebula/14.png" alt=""> 

### Flag 15
This was pretty hard. I definitely need to review this.
Extremely useful resources for this challenge: https://www.lurklurk.org/linkers/linkers.html  
https://www3.physnet.uni-hamburg.de/physnet/Tru64-Unix/HTML/APS31DTE/DOCU_002.HTM#reldyn_section  
Questions I had when writing the code:
1) What are the include headers that I need?
2) What arguments and parameters should I pass to the __libc_start_main() function?
3) What extra flags do I need during the compilation process?

For this exercise, I used strace in order to determine the dependencies associated with the flag15 program. Using strace, I saw that it tried to open a file called libc.so.6 in a directory that always began with /var/tmp/flag15/[random extra path]. The attack probably involves me using this nonexistent file to create a program that starts a shell as a privileged user.

<img src = "/csec-writeups/exploited/nebula/15-1.png" alt="">

I used objdump -R flag15 to get information about the program. Specifically, objdump is a command that displays information about the object file flag15. The flag -R prints the dynamic relocation entries of the file. It allows me to look at the functions used by the shared library that is libc.so.6. The command readelf -a flag15 tells me the path where the libc.so.6 file must be located. 

<img src = "/csec-writeups/exploited/nebula/15-2.png" alt="">

<br/>

<img src = "/csec-writeups/exploited/nebula/15-3.png" alt="">

After examining the output of the two commands, I saw that the libc.so.6 file contains a main function called __libc_start_main(). I created a program called flag15.c that contained the following code. I compiled the program using the command  
gcc -shared -fPIC -o libc.so.6 flag15.c  
The -shared flag indicates that this is a shared library as opposed to a static library. Without the shared flag, the compiler will ask for a main function. 
The -fPIC flag indicates that this is position independent code meaning that the machine generated code doesnt not depend on it being at a specific location. 

<a href="https://stackoverflow.com/questions/5311515/gcc-fpic-option"> https://stackoverflow.com/questions/5311515/gcc-fpic-option </a>

After compiling the program and running it, I saw that there was an error stating that version GLIBC_2.0 was not defined in the file libc.so.6 with link time reference. I addressed this problem by creating a script with the version as shown here: <a href="https://github.com/dillonwu-97/csec-code/blob/main/exploit-ed/nebula/flag15_version_script"> https://github.com/dillonwu-97/csec-code/blob/main/exploit-ed/nebula/flag15_version_script </a>. I think the script file needs to contain both GLIBC_2.0{} and GLIBC_2.1.3{} (although I can be wrong about this, I need to double check). I chose those particular versions because of the output from the readelf command, and the error output. 
<img src = "/csec-writeups/exploited/nebula/15-4.png" alt=""> <br/>
<img src = "/csec-writeups/exploited/nebula/15-5.png" alt="">

At this point, I compiled the program using the commands  
gcc -shared -fPIC -o libc.so.6 flag15.c -Wl,--version-script=version_script

<img src = "/csec-writeups/exploited/nebula/15-6.png" alt="">

However, I got another compilation error stating that I was missing the function __cxa_finalize. I created the function with an empty return statement, and recompiled. 

There was one final problem, which was that the command system was not recognized. In order to address this issue, I had to compile the code statically so that it includes all the libraries that it needs. 
<img src = "/csec-writeups/exploited/nebula/15-7.png" alt="">

The final compilation command is as follows:  
The flag -Bstatic means that we are not linking against shared libraries. We need this flag to tell the compiler that all of the dynamic / shared library's (libc.so.6) external references are resolved by pulling from static libraries. I think -static-libgcc is the static library that the command system is being pulled from but I could be wrong about this.

gcc -shared -static-libgcc -fPIC -o libc.so.6 flag15.c -Wl,--version-script=version_script,-Bstatic 

The final code for this exploit is detailed here: <a href="https://github.com/dillonwu-97/csec-code/blob/main/exploit-ed/nebula/flag15.c"> https://github.com/dillonwu-97/csec-code/blob/main/exploit-ed/nebula/flag15.c </a>.  

<img src = "/csec-writeups/exploited/nebula/15-8.png" alt="">

### Flag 16
There is an injection vulnerability in the code, specifically in the @output variable assignment portion. Instead of completing the egrep command, we can instead end the command and call getflag with root permissions using the injection:  
;\`/*/FLAG16.SH\`;  

<img src = "/csec-writeups/exploited/nebula/16-1.png">
The injection works because bash will search all directories for the FLAG16.SH script to execute. We had to make it caps and use * since there are no spaces allowed, and the code converts any input to capital letters. I tried to create aliases and soft links, but it didn't work because the links and aliases are only associated with the user level16 instead of the user flag16.  
Finally, to trigger the vulnerability, we use the command:  
wget http://localhost:1616/index.cgi?username=%3B%60%2F*%2FFLAG16.SH%60%3B&password=hi  which is the urlencoded version of wget http://localhost:1616/index.cgi?username=;\`/*/FLAG16.SH\`;

<img src = "/csec-writeups/exploited/nebula/16-3.png">

### Flag 17
The exploit associated with this program is in the pickle function, which allows the deserialization of arbitrary input. Specifically, when pickle deserializes an object with a __reduce__ function, that function is called. A good explanation of the exploit is detailed here: <a href="https://blog.nelhage.com/2011/03/exploiting-pickle/"> https://blog.nelhage.com/2011/03/exploiting-pickle/ </a>. The code for the exploit can be found here: <a href="https://github.com/dillonwu-97/csec-code/blob/main/exploit-ed/nebula/flag17.py"> https://github.com/dillonwu-97/csec-code/blob/main/exploit-ed/nebula/flag17.py </a>.

<img src = "/csec-writeups/exploited/nebula/17-1.png" alt=""> <br/>
<img src = "/csec-writeups/exploited/nebula/17-2.png" alt=""> 

### Flag 18
There are multiple attack paths for this box. I currently have one of them outlined below which involves maxing out the number of file descriptors. 
The link here <a href="https://stackoverflow.com/questions/19779201/c-program-fails-to-get-file-descriptor-only-when-running-with-gdb"> https://blog.nelhage.com/2011/03/exploiting-pickle/ </a> provides a good explanation as to why I can't use the trick from flag13 to read the value of the password file in gdb. Instead, I have to use the attack methodology outlined below:
1) find out the maximum number of file descriptors that can be opened
2) run ./flag18 and send to background. the code for flag18 is found here: 
<a href="https://github.com/dillonwu-97/csec-code/blob/main/exploit-ed/nebula/flag18.c"> https://github.com/dillonwu-97/csec-code/blob/main/exploit-ed/nebula/flag18.c </a>
<a href="https://github.com/dillonwu-97/csec-code/blob/main/exploit-ed/nebula/flag18.sh"> https://github.com/dillonwu-97/csec-code/blob/main/exploit-ed/nebula/flag18.sh </a>
2) open all the file descriptors
3) pass the parameter "login" to the vulnerable code
4) wait for file descriptors to close
5) pass "shell" into the vulnerable code to call execve for shell

<img src = "/csec-writeups/exploited/nebula/18-1.png" alt=""> 

Some of the important commands are explained and listed below
You can check out the max number of file descriptors available by cat-ing /proc/sys/fs/file-max.
You can check current number of file descriptors oepn using sysctl fs.file-nr.
ulimit -n <-- shows the current max number of file descriptors that can be opened by a process
ulimit -Hn <-- check the hard limit for the max number of fd
ulimit -Sn 4096 <-- set the soft limit for the max number

### Flag 19
For this exercise, you have to know that when a parent process dies before a child process, then the child process' parent becomes init which is owned by root. So, for this exploit, kill the parent process, and then call flag19 from the child process. The code can be found here: <a href="https://github.com/dillonwu-97/csec-code/blob/main/exploit-ed/nebula/flag19.c"> https://github.com/dillonwu-97/csec-code/blob/main/exploit-ed/nebula/flag19.c </a>. 

<br/>
<img src = "/csec-writeups/exploited/nebula/19.png">